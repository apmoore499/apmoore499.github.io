<!DOCTYPE html><html lang="en-US"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><title>3. Detect open / closed regions - Archer</title><link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script><meta name="viewport" content="width=device-width, initial-scale=1"><title>Detect open / closed regions | Archer</title><meta name="generator" content="Jekyll v3.8.5" /><meta property="og:title" content="Detect open / closed regions" /><meta property="og:locale" content="en_US" /><meta name="description" content="PhD repository" /><meta property="og:description" content="PhD repository" /><link rel="canonical" href="http://localhost:4000/docs/circuitSNP/code/3_analyse_lcl_chromatin/" /><meta property="og:url" content="http://localhost:4000/docs/circuitSNP/code/3_analyse_lcl_chromatin/" /><meta property="og:site_name" content="Archer" /> <script type="application/ld+json"> {"@type":"WebPage","url":"http://localhost:4000/docs/circuitSNP/code/3_analyse_lcl_chromatin/","headline":"Detect open / closed regions","description":"PhD repository","@context":"https://schema.org"}</script><body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="link" viewBox="0 0 16 16"><title>Link</title><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path> </symbol> </svg><div class="page-wrap"><div class="side-bar"><div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight"> Archer </a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button></div><div class="navigation main-nav js-main-nav"><nav role="navigation" aria-label="Main navigation"><ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/docs/circuitSNP/code/6_split_data_for_denny_NN/" class="navigation-list-link"></a><li class="navigation-list-item active"><a href="http://localhost:4000/docs/circuitSNP/code/snp_vec_creation/" class="navigation-list-link"></a><li class="navigation-list-item"><a href="http://localhost:4000/docs/circuitSNP/code/split_data/" class="navigation-list-link">Now we split data</a><li class="navigation-list-item"><a href="http://localhost:4000/docs/github%20misc/github/" class="navigation-list-link">Github doc</a><li class="navigation-list-item active"><a href="http://localhost:4000/docs/hpc/copying_data_to_hpc/" class="navigation-list-link"></a><li class="navigation-list-item"><a href="http://localhost:4000/" class="navigation-list-link">Home</a><li class="navigation-list-item"><a href="http://localhost:4000/docs/circuitSNP/circuitSNP/" class="navigation-list-link">circuitSNP</a><ul class="navigation-list-child-list "><li class="navigation-list-item active"><a href="http://localhost:4000/docs/circuitSNP/code/code_documentation/" class="navigation-list-link">Python Implementation</a><ul class="navigation-list-child-list"><li class="navigation-list-item "> <a href="http://localhost:4000/docs/circuitSNP/code/1_preliminary_setup/" class="navigation-list-link">1. Environment Configuration</a><li class="navigation-list-item "> <a href="http://localhost:4000/docs/circuitSNP/code/2_download_data/" class="navigation-list-link">2. Download data</a><li class="navigation-list-item active"> <a href="http://localhost:4000/docs/circuitSNP/code/3_analyse_lcl_chromatin/" class="navigation-list-link active">3. Detect open / closed regions</a><li class="navigation-list-item "> <a href="http://localhost:4000/docs/circuitSNP/code/4_analyse_motif_window_membership/" class="navigation-list-link">4. Motif membership</a><li class="navigation-list-item "> <a href="http://localhost:4000/docs/circuitSNP/code/5_generate_T_matrix/" class="navigation-list-link">5. Generate T matrix</a><li class="navigation-list-item "> <a href="http://localhost:4000/docs/circuitSNP/code/7_run_NN/" class="navigation-list-link">6. Run NN</a><li class="navigation-list-item "> <a href="http://localhost:4000/docs/circuitSNP/code/functions/" class="navigation-list-link">Imports and functions</a></ul></ul><li class="navigation-list-item"><a href="http://localhost:4000/docs/hpc/spartan/" class="navigation-list-link">Spartan HPC Usage</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/hpc/slurm/" class="navigation-list-link">Slurm example script</a></ul><li class="navigation-list-item"><a href="http://localhost:4000/docs/jekyll_maintenance/jekyll_setup/" class="navigation-list-link">Web Development</a></ul></nav></div><footer class="site-footer"><p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p></footer></div><div class="main-content-wrap js-main-content" tabindex="0"><div class="main-content"><div class="page-header js-page-header"><div class="search"><div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Archer" aria-label="Search Archer" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg></div><div class="js-search-results search-results-wrap"></div></div></div><div class="page"><nav class="breadcrumb-nav"><ol class="breadcrumb-nav-list"><li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/docs/hpc/copying_data_to_hpc/">Python Implementation</a><li class="breadcrumb-nav-list-item"><span>3. Detect open / closed regions</span></ol></nav><div id="main-content" class="page-content" role="main"><h5 id="back-to-contents"> <a href="#back-to-contents" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> <a href="./..">Back to contents</a></h5><p>The previous step retrieved the locations of open chromatin windows in LCL and ALL tissues.</p><p>The goal of this step is to use these locations to derive regions of open and closed chromatin between both tissue types.</p><p>Specifically, we want to see whether chromatin that was previously open in ALL tissue has been closed in LCL tissue, or has been kept open.</p><p>Open and closed regions of chromatin are classified as follows:</p><ul><li><p>Chromatin open: footprints in region of ALL tissues overlap with footprints in region of LCL tissues</p><li><p>Chromatin closed: footprints in region of ALL tissues do not overlap with any footprint in LCL tissues</p></ul><h5 id="source-code-analyse_footprint_overlappy"> <a href="#source-code-analyse_footprint_overlappy" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> Source Code: <a href="../analyse_footprint_overlap.py">./analyse_footprint_overlap.py</a></h5><p>The python script to analyse chromatin openness is run in bash terminal:</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python ./analyse_footprint_overlap.py
</code></pre></div></div><p>This project uses pandas dataframes - this data structure is helpful for manipulating tables and extracting values (this data format was copied from R). Documentation on pandas dataframe here: <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html</a></p><p>We read csv files as dataframe objects with the following call:</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="o">&lt;</span><span class="n">dataframe_object</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'file.csv'</span><span class="p">)</span>
</code></pre></div></div><p>So now letâ€™s load reads for ALL tissus and LCL tissues</p><p>Load ALL reads:</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#ALL reads
</span><span class="n">openALL</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"rawdata/wgEncodeRegDnaseClusteredV3.bed"</span><span class="p">,</span><span class="s">'r'</span><span class="p">)</span>
<span class="c1">#read in files as data frame usign pandas
</span><span class="n">all_reads</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">openALL</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div><p>Rename columns</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">all_reads</span><span class="o">.</span><span class="n">colnames</span><span class="o">=</span><span class="p">[</span><span class="s">'chrom'</span><span class="p">,</span><span class="s">'start'</span><span class="p">,</span><span class="s">'stop'</span><span class="p">,</span><span class="s">'1'</span><span class="p">,</span><span class="s">'2'</span><span class="p">,</span><span class="s">'3'</span><span class="p">,</span><span class="s">'4'</span><span class="p">,</span><span class="s">'5'</span><span class="p">]</span>
<span class="n">all_reads</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">all_reads</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="nb">str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</code></pre></div></div><p>Do same for LCL</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#LCL reads
</span><span class="n">openLCL</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"rawdata/wgEncodeAwgDnaseUwdukeGm12878UniPk.narrowPeak"</span><span class="p">,</span><span class="s">'r'</span><span class="p">)</span>
<span class="c1">#read in files as data frame usign pandas
</span><span class="n">lcl_reads</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">openLCL</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div><p>Create column to store whether chromatin is open or closed</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#chromatin_open column refers to whether chromatin is open or closed
</span><span class="n">all_reads</span><span class="p">[</span><span class="s">"chromatin_open"</span><span class="p">]</span><span class="o">=</span><span class="s">""</span>
<span class="n">all_reads</span><span class="p">[</span><span class="s">"chromatin_overlap"</span><span class="p">]</span><span class="o">=</span><span class="s">""</span>
</code></pre></div></div><p>Comparing elements is very slow unless we use the GPU.</p><p>GPU functions can only work on arrays - they cannot work on dataframes directly.</p><p>So now extract relevant variables as arrays to be passed in.</p><p>Relevant variables are the start and stop locations of reads for ALL and LCL tissue types</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#extract arrays to pass into function
</span><span class="n">all_start</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_reads</span><span class="p">[</span><span class="s">'start'</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">all_stop</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_reads</span><span class="p">[</span><span class="s">'stop'</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">lcl_start</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lcl_reads</span><span class="p">[</span><span class="s">'start'</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">lcl_stop</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lcl_reads</span><span class="p">[</span><span class="s">'stop'</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</code></pre></div></div><p>The chromosome identifier is given as a string, but we need to to convert this to an int, becuase GPU cannot work on string arrays.</p><p>So create a dictionary for unique chromosome names called â€˜chrom_dictâ€™</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#get unique values for chromosome column in ALL and LCL data
</span><span class="n">all_chrom</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">all_reads</span><span class="p">[</span><span class="s">'chrom'</span><span class="p">])</span>
<span class="n">lcl_chrom</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">lcl_reads</span><span class="p">[</span><span class="s">'chrom'</span><span class="p">])</span>
<span class="c1">#Create the union of all chromosomes in either ALL and LCL data
</span><span class="n">total_chrom</span><span class="o">=</span><span class="n">all_chrom</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">lcl_chrom</span><span class="p">)</span>

<span class="c1">#as we cannot pass string values into GPU parallel function,
#construct dictionary so that we can group by chromosome indexed by integer
</span><span class="n">chrom_dict</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">chrom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">total_chrom</span><span class="p">):</span>
	<span class="n">chrom_dict</span><span class="p">[</span><span class="n">chrom</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>

</code></pre></div></div><p>Now map chromosome dictionary values back to each read via a new column called â€˜chrom_dictâ€™</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#now use this to replace in lcl and all (convert to integer)
</span><span class="n">all_reads</span><span class="p">[</span><span class="s">'chrom_dict'</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_reads</span><span class="p">[</span><span class="s">'chrom'</span><span class="p">]</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="n">chrom_dict</span><span class="p">)</span>
<span class="n">lcl_reads</span><span class="p">[</span><span class="s">'chrom_dict'</span><span class="p">]</span> <span class="o">=</span> <span class="n">lcl_reads</span><span class="p">[</span><span class="s">'chrom'</span><span class="p">]</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="n">chrom_dict</span><span class="p">)</span>
</code></pre></div></div><p>And then extract chromosome arrays for ALL and LCL tissues so that we can use them to analyse overlapping regions</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#extract chromosomes as list to pass into function
</span><span class="n">all_chrom</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_reads</span><span class="p">[</span><span class="s">'chrom_dict'</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">lcl_chrom</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lcl_reads</span><span class="p">[</span><span class="s">'chrom_dict'</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</code></pre></div></div><p>Now setup input arrays on GPU cluster</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># move input data to the GPU cluster
</span><span class="n">d_all_start</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">all_start</span><span class="p">)</span>
<span class="n">d_all_stop</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">all_stop</span><span class="p">)</span>
<span class="n">d_lcl_start</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">lcl_start</span><span class="p">)</span>
<span class="n">d_lcl_stop</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">lcl_stop</span><span class="p">)</span>
<span class="n">d_all_chrom</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">all_chrom</span><span class="p">)</span>
<span class="n">d_lcl_chrom</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">lcl_chrom</span><span class="p">)</span>
</code></pre></div></div><p>Set up output arrays on GPU cluster</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># create arrays on GPU cluster to allow data to be retrieved from cluster
</span><span class="n">d_chromatin_open</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">device_array_like</span><span class="p">(</span><span class="n">d_all_start</span><span class="p">)</span>
<span class="n">d_window_start</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">device_array_like</span><span class="p">(</span><span class="n">d_all_start</span><span class="p">)</span>
<span class="n">d_window_end</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">device_array_like</span><span class="p">(</span><span class="n">d_all_start</span><span class="p">)</span>
<span class="n">d_window_start_id</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">device_array_like</span><span class="p">(</span><span class="n">d_lcl_id</span><span class="p">)</span>
<span class="n">d_window_end_id</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">device_array_like</span><span class="p">(</span><span class="n">d_lcl_id</span><span class="p">)</span>

</code></pre></div></div><p>We also have to set window length. Here have used 300. The script will raise exception if length not divisible by 2.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#set window length - must be divisible by 2
</span><span class="n">WINDOW_LENGTH</span><span class="o">=</span><span class="mi">300</span>
</code></pre></div></div><p>Now, ready to set up function <code class="language-plaintext highlighter-rouge">check_chromatin_open()</code></p><p><code class="language-plaintext highlighter-rouge">check_chromatin_open()</code> performs analysis of overlapping regions, explained as follows</p><p>Define <code class="language-plaintext highlighter-rouge">@cuda.jit</code> to make run on GPU</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Define function check_chromatin_open to perform analysis of overlap
</span><span class="o">@</span><span class="n">cuda</span><span class="o">.</span><span class="n">jit</span>
<span class="k">def</span> <span class="nf">check_chromatin_open</span><span class="p">(</span>
	<span class="n">al_start</span><span class="p">,</span>
	<span class="n">al_end</span><span class="p">,</span>
	<span class="n">lc_start</span><span class="p">,</span>
	<span class="n">lc_end</span><span class="p">,</span>
	<span class="n">al_chrom</span><span class="p">,</span>
	<span class="n">lc_chrom</span><span class="p">,</span>
	<span class="n">chromatin_open</span><span class="p">,</span>
	<span class="n">window_start</span><span class="p">,</span>
	<span class="n">window_end</span><span class="p">,</span>
	<span class="n">window_start_id</span><span class="p">,</span>
	<span class="n">window_end_id</span><span class="p">):</span>
</code></pre></div></div><p>Loop thru every read for ALL and every read for LCL. If we get any overlapping regions then make a note of this in the chromatin open state for the corresponding row in ALL.</p><p>Reads are are overlapping if the open chromatin regions overlap like this:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Read 1:	  	 #-------------#
Read 2:	   #----------------#
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">#</code> refers to a start or end point <code class="language-plaintext highlighter-rouge">---</code> refers to a set of alleles</p><p>This depicts that read 1 terminates before read 2. Consider that read 1 might terminate after read 2:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Read 1:	  	 #-----------------#
Read 2:	   #----------------#
</code></pre></div></div><p>For this analysis, ignore where the Read 1 ends. Denote this as <code class="language-plaintext highlighter-rouge">/</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Read 1:	  	 #-------------/
Read 2:	   #----------------#
</code></pre></div></div><p>Which means that read 1 might terminate before read 2 terminates, or after. It doesnâ€™t matter - weâ€™re only looking at which read starts the overlapping region.</p><p>Now, check for overlap with either LCL starting region, or ALL starting region.</p><p>We have two conditions to match:</p><h5 id="lcl-starts-the-overlapping-region"> <a href="#lcl-starts-the-overlapping-region" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> LCL starts the overlapping region</h5><p>First, check chromosome is the same: <code class="language-plaintext highlighter-rouge">al_chrom[i1]==lc_chrom[i2]</code></p><p>Then, check that LCL starts the region</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">al_chrom</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">==</span><span class="n">lc_chrom</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">lc_start</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">al_start</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">al_start</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">lc_end</span><span class="p">[</span><span class="n">i2</span><span class="p">]:</span>
	<span class="c1">#this is case where we have:
</span>	<span class="c1"># ALL  	 #-------------/
</span>	<span class="c1"># LCL   #----------------#
</span>	
	<span class="n">chromatin_open</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="n">window_start</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">lc_start</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span>
	<span class="n">window_start_id</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">i2</span><span class="o">+</span><span class="mf">0.0003</span>
</code></pre></div></div><h5 id="all-starts-read"> <a href="#all-starts-read" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> ALL starts read</h5><p>First, check chromosome is the same: <code class="language-plaintext highlighter-rouge">al_chrom[i1]==lc_chrom[i2]</code></p><p>Then, check that ALL starts the region</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">elif</span> <span class="n">al_chrom</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">==</span><span class="n">lc_chrom</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">al_start</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">lc_start</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">lc_start</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">al_end</span><span class="p">[</span><span class="n">i1</span><span class="p">]:</span>
	<span class="c1">#this is case where we have:
</span>	<span class="c1"># ALL  #-------------/
</span>	<span class="c1"># LCL   #----------------#
</span></code></pre></div></div><p>Now, we have to make window 300bp long</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#now, extend window to be 300bp as defined in WINDOW_LENGTH
#borrowed from Denny Shin's code line 135 of dataprep.py
</span><span class="n">half_window_length</span><span class="o">=</span><span class="n">WINDOW_LENGTH</span><span class="o">/</span><span class="mi">2</span> <span class="c1">#need to have window for either side
</span><span class="n">centroid</span><span class="o">=</span><span class="n">window_start</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">+</span><span class="n">window_end</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span>
<span class="n">resized_window_start</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">centroid</span><span class="o">-</span><span class="n">half_window_length</span><span class="o">-</span><span class="mi">1</span>
<span class="n">resized_window_end</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">centroid</span><span class="o">+</span><span class="n">half_window_length</span>
</code></pre></div></div><p>Finally check that the new window encapsulates limits of old window</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">resized_window_start</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">window_start</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">resized_window_end</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">window_start</span><span class="p">[</span><span class="n">i1</span><span class="p">]:</span>
	<span class="c1">#so this corresponds to:
</span>	<span class="c1">#RESIZED WINDOW	        #------------------------#
</span>	<span class="c1">#WINDOW	 		    #------------------#
</span>	<span class="n">window_encapsulates_limits</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="c1">#if the window steps outside the original window, flag this - might come in handy later for troubleshooting
</span><span class="k">else</span><span class="p">:</span>
	<span class="n">window_encapsulates_limits</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
</code></pre></div></div><p>In order to call function on GPU, we must specify number of blocks = 1000 and block size = 256</p><p>These values are chosen by trying out different values - they run ~ 6 seconds.</p><p>We must call function and then call cuda.synchronise() to wait for all cores to finish before proceeding</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">check_chromatin_open</span><span class="p">[</span><span class="mi">1000</span><span class="p">,</span><span class="mi">256</span><span class="p">](</span>
	<span class="n">d_all_start</span><span class="p">,</span>
	<span class="n">d_all_stop</span><span class="p">,</span>
	<span class="n">d_lcl_start</span><span class="p">,</span>
	<span class="n">d_lcl_stop</span> <span class="p">,</span>
	<span class="n">d_all_chrom</span><span class="p">,</span>
	<span class="n">d_lcl_chrom</span><span class="p">,</span>
	<span class="n">d_chromatin_open</span><span class="p">,</span>
	<span class="n">d_window_start</span><span class="p">,</span>
	<span class="n">d_window_end</span><span class="p">,</span>
	<span class="n">d_window_start_id</span><span class="p">,</span>
	<span class="n">d_window_end_id</span><span class="p">)</span>
<span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
</code></pre></div></div><p>Now we can extract data from cluster using copy_to_host() syntax</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#now add results to all_reads and then save out...
</span><span class="n">all_reads</span><span class="p">[</span><span class="s">'d_chromatin_open'</span><span class="p">]</span><span class="o">=</span><span class="n">d_chromatin_open</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">()</span>
<span class="n">all_reads</span><span class="p">[</span><span class="s">'d_window_start'</span><span class="p">]</span><span class="o">=</span><span class="n">d_window_start</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">()</span>
<span class="n">all_reads</span><span class="p">[</span><span class="s">'d_window_end'</span><span class="p">]</span><span class="o">=</span><span class="n">d_window_end</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">()</span>
<span class="n">all_reads</span><span class="p">[</span><span class="s">'d_window_start_id'</span><span class="p">]</span><span class="o">=</span><span class="n">d_window_start_id</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">()</span>
<span class="n">all_reads</span><span class="p">[</span><span class="s">'d_window_end_id'</span><span class="p">]</span><span class="o">=</span><span class="n">d_window_end_id</span><span class="o">.</span><span class="n">copy_to_host</span><span class="p">()</span>
</code></pre></div></div><p>Save results</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#now write out chromatin_open...
</span><span class="n">all_reads</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s">'chromatin_reads.csv'</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div><h5 id="back-to-contents-1"> <a href="#back-to-contents-1" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> <a href="./..">Back to contents</a></h5></div></div></div></div>
